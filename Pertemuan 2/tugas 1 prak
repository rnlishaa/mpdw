---
title: "MPDW PRAK"
author: "Raihanah Nurkhalishah"
date: "2025-09-01"
output: html_document
---

```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
library(ggplot2)
```

### Input Data
```{r}
bitcoin = read.csv("C:/Users/Imam/Downloads/archive (1)/btc_historical_price.csv")
View(bitcoin)
```

```{r}
str(bitcoin)
```
```{r}
bitcoinpart <- bitcoin[2485:3311, ]
dim(bitcoinpart)
str(bitcoinpart)
View(bitcoinpart)
```
memilih baris 2485-3311 
```{r}
# ubah ke time series
bitcoin_ts <- ts(bitcoinpart$price)
```

```{r}
summary(bitcoin_ts)
```

# Membuat Plot Time Series
```{r}
library(xts)
bitcoinpart$date <- as.Date(bitcoinpart$date)
bitcoin_xts <- xts(bitcoinpart$price, order.by = bitcoinpart$date)

plot(bitcoin_xts, main="Bitcoin Daily Price", ylab="Price", xlab="Date")

```

# Smoothing Data
### Pembagian data
```{r}
n <- nrow(bitcoinpart)
n_train <- floor(0.8 * n)

# bagi data (train & test)
training_btc <- bitcoinpart[1:n_train, ]
testing_btc  <- bitcoinpart[(n_train+1):n, ]

train_btc.ts <- ts(training_btc$price)
test_btc.ts  <- ts(testing_btc$price)
```
### Eksplorasi data
```{r}
#eksplorasi keseluruhan data
plot(bitcoin_ts, col="red",main="Plot semua data")
points(bitcoin_ts)
```

```{r}
#eksplorasi data latih
plot(train_btc.ts, col="blue", main="Plot Data Latih Bitcoin", ylab="Harga Bitcoin", xlab="Waktu")
points(train_btc.ts)
```

```{r}
# eksplorasi data uji
plot(test_btc.ts, col="magenta", main="Plot Data Uji Bitcoin", ylab="Harga Bitcoin", xlab="Waktu")
points(test_btc.ts)
```

```{r}
ggplot() + 
  geom_line(data = training_btc, aes(x = date, y = price, col = "Data Latih")) +
  geom_line(data = testing_btc, aes(x = date, y = price, col = "Data Uji")) +
  labs(x = "Periode Waktu", y = "Harga Bitcoin", color = "Legend") +
  scale_colour_manual(name = "Keterangan:", 
                      breaks = c("Data Latih", "Data Uji"),
                      values = c("blue", "red")) + 
  theme_bw() + 
  theme(legend.position = "bottom",
        plot.caption = element_text(hjust = 0.5, size = 12))
```

## Single Moving Average
```{r}
data.sma <- SMA(train_btc.ts, n=4)
data.sma
```

```{r}
data.ramal<-c(NA,data.sma)
data.ramal
```
```{r}
length(bitcoin_ts)      # total data
length(train_btc.ts)  # data train
length(test_btc.ts)   # data uji
```
```{r}
data.gab <- cbind(
  aktual   = c(bitcoin_ts),
  pemulusan = c(data.sma, rep(NA, 166)),
  ramalan   = c(data.ramal, rep(data.ramal[length(data.ramal)], 165))
)

head(data.gab, 20) # cek beberapa baris awal
tail(data.gab, 20) # cek beberapa baris akhir
```
## SSE, MSE, MAPE (SMA)
### Menghitung nilai keakuratan data train
```{r}
error_train.sma = train_btc.ts-data.ramal[1:length(train_btc.ts)]

SSE_train.sma = sum(error_train.sma[5:length(train_btc.ts)]^2)
MSE_train.sma = mean(error_train.sma[5:length(train_btc.ts)]^2)
MAPE_train.sma = mean(abs((error_train.sma[5:length(train_btc.ts)]/train_btc.ts[5:length(train_btc.ts)])*100))

akurasi_train.sma <- matrix(c(SSE_train.sma, MSE_train.sma, MAPE_train.sma))
row.names(akurasi_train.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_train.sma) <- c("Akurasi m = 4")
akurasi_train.sma
```

### Menghitung nilai keakuratan data test
```{r}
# error antara data uji dengan ramalan
error_test.sma <- test_btc.ts - data.gab[(length(train_btc.ts)+1):length(bitcoin_ts), 3]

# hitung SSE, MSE, MAPE
SSE_test.sma <- sum(error_test.sma^2, na.rm=TRUE)
MSE_test.sma <- mean(error_test.sma^2, na.rm=TRUE)
MAPE_test.sma <- mean(abs(error_test.sma/test_btc.ts)*100, na.rm=TRUE)

akurasi_test.sma <- matrix(c(SSE_test.sma, MSE_test.sma, MAPE_test.sma))
row.names(akurasi_test.sma) <- c("SSE","MSE","MAPE")
colnames(akurasi_test.sma) <- c("Akurasi m=4")
akurasi_test.sma

```

### Double Moving Average (DMA) 
```{r}
dma <- SMA(data.sma, n = 4)
At <- 2*data.sma - dma
Bt <- 2/(4-1)*(data.sma - dma)
data.dma<- At+Bt
data.ramal2<- c(NA, data.dma)

t = 1:166
f = c()

for (i in t) {
  f[i] = At[length(At)] + Bt[length(Bt)]*(i)
}

data.gab2 <- cbind(aktual = c(bitcoin_ts), 
                   pemulusan1 = c(data.sma,rep(NA,166)),
                   pemulusan2 = c(dma, rep(NA,166)),
                   At = c(At, rep(NA,166)), 
                   Bt = c(Bt,rep(NA,166)),
                   ramalan = c(data.ramal2, f[-1]))
data.gab2
```
Hasil pemulusan menggunakan metode DMA divisualisasikan sebagai berikut
```{r}
ts.plot(bitcoin_ts, xlab="Time Period ", ylab="bitcoin price", main= "DMA N=4 bitcoin")
points(bitcoin_ts)
lines(data.gab2[,3],col="green",lwd=2)
lines(data.gab2[,6],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.5)
```
Selanjutnya perhitungan akurasi dilakukan baik pada data latih maupun data uji. Perhitungan akurasi dilakukan dengan ukuran akurasi SSE, MSE dan MAPE.
```{r}
#Menghitung nilai keakuratan data latih
error_train.dma = train_btc.ts-data.ramal2[1:length(train_btc.ts)]

SSE_train.dma = sum(error_train.dma[8:length(train_btc.ts)]^2)
MSE_train.dma = mean(error_train.dma[8:length(train_btc.ts)]^2)
MAPE_train.dma = mean(abs((error_train.dma[8:length(train_btc.ts)]/train_btc.ts[8:length(train_btc.ts)])*100))

akurasi_train.dma <- matrix(c(SSE_train.dma, MSE_train.dma, MAPE_train.dma))
row.names(akurasi_train.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_train.dma) <- c("Akurasi m = 4")
akurasi_train.dma
```

Perhitungan akurasi pada data latih menggunakan nilai MAPE menghasilkan nilai MAPE yang kurang dari 10% sehingga dikategorikan sangat baik. Selanjutnya, perhitungan nilai akurasi dilakukan pada data uji.

```{r}
#Menghitung nilai keakuratan data uji
error_test.dma <- test_btc.ts - data.gab2[(length(train_btc.ts)+1):length(bitcoin_ts), 6]

# hitung SSE, MSE, MAPE
SSE_test.dma <- sum(error_test.dma^2, na.rm=TRUE)
MSE_test.dma <- mean(error_test.dma^2, na.rm=TRUE)
MAPE_test.dma <- mean(abs(error_test.dma/test_btc.ts)*100, na.rm=TRUE)

akurasi_test.dma <- matrix(c(SSE_test.dma, MSE_test.dma, MAPE_test.dma))
row.names(akurasi_test.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_test.dma) <- c("Akurasi m = 4")
akurasi_test.dma

```
Perhitungan akurasi menggunakan data latih menghasilkan nilai MAPE sebesar 32% sehingga nilai akurasi ini dapat dikategorikan sebagai kurang baik.
Pada data latih, metode DMA lebih baik dibandingkan dengan metode SMA, sedangkan pada data uji, metode SMA lebih baik dibandingkan DMA.

## Single Exponential Smoothing & Double Exponential Smoothing

### Single Exponential Smoothing

```{r}
#Cara 1 (fungsi ses)
ses.1 <- ses(train_btc.ts, h = 10, alpha = 0.2)
plot(ses.1)
```

```{r}
ses.2<- ses(train_btc.ts, h = 10, alpha = 0.7)
plot(ses.2)
```

```{r}
autoplot(ses.1) +
  autolayer(fitted(ses.1), series="Fitted") +
  ylab("bitcoin prices") + xlab("Periode")
```
Selanjutnya akan digunakan fungsi `HoltWinters()` dengan nilai inisialisasi parameter dan panjang periode peramalan yang sama dengan fungsi `ses()` .
```{r}
#Cara 2 (fungsi Holtwinter)
ses1<- HoltWinters(train_btc.ts, gamma = FALSE, beta = FALSE, alpha = 0.2)
plot(ses1)
ses1
```

```{r}
#ramalan
ramalan1<- forecast(ses1, h=10)
ramalan1
```


```{r}
ses2<- HoltWinters(train_btc.ts, gamma = FALSE, beta = FALSE, alpha = 0.7)
plot(ses2)
```


```{r}
#ramalan
ramalan2<- forecast(ses2, h=10)
ramalan2
```
```{r}
#SES
ses.opt <- ses(train_btc.ts, h = 10, alpha = NULL)
plot(ses.opt)
ses.opt
```


```{r}
#Lamda Optimum Holt Winter
HWopt<- HoltWinters(train_btc.ts, gamma = FALSE, beta = FALSE,alpha = NULL)
plot(HWopt)
```


```{r}
#ramalan
ramalanopt<- forecast(HWopt, h=10)
ramalanopt
```

Setelah dilakukan peramalan, akan dilakukan perhitungan keakuratan hasil peramalan. Perhitungan akurasi ini dilakukan baik pada data latih dan data uji.

#### Akurasi Data Latih

Perhitungan akurasi data dapat dilakukan dengan cara langsung maupun manual. Secara langsung, nilai akurasi dapat diambil dari objek yang tersimpan pada hasil SES, yaitu *sum of squared errors* (SSE). Nilai akurasi lain dapat dihitung pula dari nilai SSE tersebut.

```{r}
#Keakuratan Metode
#Pada data training

# SES dengan alpha = 0.2
SSE1<-ses1$SSE
MSE1<-ses1$SSE/length(train_btc.ts)
RMSE1<-sqrt(MSE1)

akurasi1 <- matrix(c(SSE1,MSE1,RMSE1))
row.names(akurasi1)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1) <- c("Akurasi lamda=0.2")
akurasi1
```


```{r}
# SES dengan alpha = 0.7
SSE2<-ses2$SSE
MSE2<-ses2$SSE/length(train_btc.ts)
RMSE2<-sqrt(MSE2)

akurasi2 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi2)<- c("SSE", "MSE", "RMSE")
colnames(akurasi2) <- c("Akurasi lamda=0.7")
akurasi2
```

Berdasarkan nilai SSE, MSE, RMSE, dan MAPE di antara kedua parameter, nilai parameter $\lambda=0,7$ menghasilkan akurasi yang lebih baik dibanding $\lambda=0,2$ . Hal ini dilihat dari nilai masing-masing ukuran akurasi yang lebih kecil. Berdasarkan nilai MAPE-nya, hasil ini dapat dikategorikan sebagai peramalan sangat baik.

#### Akurasi Data Uji

Akurasi data uji dapat dihitung dengan cara yang hampir sama dengan perhitungan akurasi data latih.

```{r}
# jumlah observasi uji
n_test <- nrow(testing_btc)

# error (ramalan - aktual), samakan panjang dan tipe numeric
e1   <- as.numeric(ramalan1$mean)[1:n_test] - as.numeric(testing_btc$price)
e2   <- as.numeric(ramalan2$mean)[1:n_test] - as.numeric(testing_btc$price)
eopt <- as.numeric(ramalanopt$mean)[1:n_test] - as.numeric(testing_btc$price)

# SSE / MSE / RMSE untuk masing-masing model (abaikan NA)
SSEtesting1  <- sum(e1^2,  na.rm = TRUE)
MSEtesting1  <- mean(e1^2, na.rm = TRUE)
RMSEtesting1 <- sqrt(MSEtesting1)

SSEtesting2  <- sum(e2^2,  na.rm = TRUE)
MSEtesting2  <- mean(e2^2, na.rm = TRUE)
RMSEtesting2 <- sqrt(MSEtesting2)

SSEtestingopt  <- sum(eopt^2,  na.rm = TRUE)
MSEtestingopt  <- mean(eopt^2, na.rm = TRUE)
RMSEtestingopt <- sqrt(MSEtestingopt)

# Tabel ringkas
akurasitesting_SSE <- matrix(c(SSEtesting1, SSEtesting2, SSEtestingopt),
                             nrow = 3,
                             dimnames = list(c("SSE1","SSE2","SSEopt"), "Nilai"))
akurasitesting_MSE <- matrix(c(MSEtesting1, MSEtesting2, MSEtestingopt),
                             nrow = 3,
                             dimnames = list(c("MSE1","MSE2","MSEopt"), "Nilai"))
akurasitesting_RMSE <- matrix(c(RMSEtesting1, RMSEtesting2, RMSEtestingopt),
                              nrow = 3,
                              dimnames = list(c("RMSE1","RMSE2","RMSEopt"), "Nilai"))

akurasitesting_SSE
```


```{r}
akurasitesting_MSE
```


```{r}
akurasitesting_RMSE

```

## *Double Exponential Smoothing* (DES)

```{r}
#Lamda=0.2 dan gamma=0.2
des.1<- HoltWinters(train_btc.ts, gamma = FALSE, beta = 0.2, alpha = 0.2)
plot(des.1)
```


```{r}
#ramalan
ramalandes1<- forecast(des.1, h=10)
ramalandes1
```


```{r}
#Lamda=0.6 dan gamma=0.3
des.2<- HoltWinters(train_btc.ts, gamma = FALSE, beta = 0.3, alpha = 0.6)
plot(des.2)
```


```{r}
#ramalan
ramalandes2<- forecast(des.2, h=10)
ramalandes2
```

Selanjutnya jika ingin membandingkan plot data latih dan data uji adalah sebagai berikut.

```{r}
plot(bitcoin_ts)
lines(des.1$fitted[,1], lty=2, col="blue")
lines(ramalandes1$mean, col="red")
```

Untuk mendapatkan nilai parameter optimum dari DES, argumen `alpha` dan `beta` dapat dibuat `NULL` seperti berikut.

```{r}
#Lamda dan gamma optimum
des.opt<- HoltWinters(train_btc.ts, gamma = FALSE)
plot(des.opt)
```


```{r}
#ramalan
ramalandesopt<- forecast(des.opt, h=10)
ramalandesopt
```

Selanjutnya akan dilakukan perhitungan akurasi pada data latih maupun data uji dengan ukuran akurasi SSE, MSE dan MAPE.

#### Akurasi Data Latih

```{r}
#Akurasi Data Training
ssedes.train1<-des.1$SSE
msedes.train1<-ssedes.train1/length(train_btc.ts)
sisaandes1<-ramalandes1$residuals
head(sisaandes1)

mapedes.train1 <- sum(abs(sisaandes1[3:length(train_btc.ts)]/train_btc.ts[3:length(train_btc.ts)])
                      *100)/length(train_btc.ts)

akurasides.1 <- matrix(c(ssedes.train1,msedes.train1,mapedes.train1))
row.names(akurasides.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.1) <- c("Akurasi lamda=0.2 dan gamma=0.2")
akurasides.1
```


```{r}
ssedes.train2<-des.2$SSE
msedes.train2<-ssedes.train2/length(train_btc.ts)
sisaandes2<-ramalandes2$residuals
head(sisaandes2)

mapedes.train2 <- sum(abs(sisaandes2[3:length(train_btc.ts)]/train_btc.ts[3:length(train_btc.ts)])
                      *100)/length(train_btc.ts)

akurasides.2 <- matrix(c(ssedes.train2,msedes.train2,mapedes.train2))
row.names(akurasides.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.2) <- c("Akurasi lamda=0.6 dan gamma=0.3")
akurasides.2
```

Hasil akurasi dari data latih didapatkan skenario 2 dengan lamda=0.6 dan gamma=0.3 memiliki hasil yang lebih baik. Namun untuk kedua skenario dapat dikategorikan peramalan sangat baik berdasarkan nilai MAPE-nya.

#### Akurasi Data Uji

```{r}
#Akurasi Data Testing
selisihdes1<- as.numeric (ramalandes1$mean) - as.numeric(testing_btc$price)
selisihdes1

SSEtestingdes1<-sum(selisihdes1^2)
MSEtestingdes1<-SSEtestingdes1/length(testing_btc$price)
MAPEtestingdes1<-sum(abs(selisihdes1/testing_btc$price)*100)/length(testing_btc$price)
```


```{r}
selisihdes2<-as.numeric (ramalandes2$mean) - as.numeric(testing_btc$price)
selisihdes2

SSEtestingdes2<-sum(selisihdes2^2)
MSEtestingdes2<-SSEtestingdes2/length(testing_btc$price)
MAPEtestingdes2<-sum(abs(selisihdes2/testing_btc$price)*100)/length(testing_btc$price)
```


```{r}
selisihdesopt<-as.numeric (ramalandesopt$mean) - as.numeric(testing_btc$price)
selisihdesopt

SSEtestingdesopt<-sum(selisihdesopt^2)
MSEtestingdesopt<-SSEtestingdesopt/length(testing_btc$price)
MAPEtestingdesopt<-sum(abs(selisihdesopt/testing_btc$price)*100)/length(testing_btc$price)
```


```{r}
akurasitestingdes <-
  matrix(c(SSEtestingdes1,MSEtestingdes1,MAPEtestingdes1,SSEtestingdes2,MSEtestingdes2,
           MAPEtestingdes2,SSEtestingdesopt,MSEtestingdesopt,MAPEtestingdesopt),
         nrow=3,ncol=3)
row.names(akurasitestingdes)<- c("SSE", "MSE", "MAPE")
colnames(akurasitestingdes) <- c("des ske1","des ske2","des opt")
akurasitestingdes
```

#### Perbandingan SES dan DES

```{r}
MSEfull <-
  matrix(c(MSEtesting1,MSEtesting2,MSEtestingopt,MSEtestingdes1,MSEtestingdes2,
           MSEtestingdesopt),nrow=3,ncol=2)
row.names(MSEfull)<- c("ske 1", "ske 2", "ske opt")
colnames(MSEfull) <- c("ses","des")
MSEfull
```
Dari hasil perhitungan, terlihat bahwa pada model Ske 2, nilai MAPE yang dihasilkan metode Single Exponential Smoothing (SES) lebih kecil dibandingkan dengan metode Double Exponential Smoothing (DES). Hal ini berarti, secara rata-rata, tingkat kesalahan relatif prediksi SES lebih rendah dibandingkan DES, sehingga SES lebih akurat dalam meramalkan data pada Ske 2. Dengan kata lain, untuk dataset ini, model SES lebih sesuai digunakan karena mampu memberikan hasil ramalan yang lebih dekat dengan nilai aktual dibandingkan model DES. Walaupun secara teori DES lebih unggul untuk data dengan trend, dalam kasus ini SES lebih sesuai karena data tidak menunjukkan trend signifikan sehingga lebih sederhana tapi justru lebih akurat.


